<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"judith-hopps.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Chapter5 数据的共享与保护函数间的数据共享 不同位置定义的变量和对象，其作用域，可见性，生存期都不同 作用域作用域是一个标识符在程序正文中有效的区域 作用域分类函数原型作用域 编译器在检查函数原型的时候，只看参数表中参数的类型，并不看参数名  在函数调用的时候，才会给形参分配空间。在声明函数原型的时候，这些形参并不对应到任何存储空间，其只是个符号     局部作用域  类作用域[类成员]">
<meta property="og:type" content="article">
<meta property="og:title" content="C++_5">
<meta property="og:url" content="https://judith-hopps.github.io/2025/02/20/C-5/index.html">
<meta property="og:site_name" content="Nick Wilde">
<meta property="og:description" content="Chapter5 数据的共享与保护函数间的数据共享 不同位置定义的变量和对象，其作用域，可见性，生存期都不同 作用域作用域是一个标识符在程序正文中有效的区域 作用域分类函数原型作用域 编译器在检查函数原型的时候，只看参数表中参数的类型，并不看参数名  在函数调用的时候，才会给形参分配空间。在声明函数原型的时候，这些形参并不对应到任何存储空间，其只是个符号     局部作用域  类作用域[类成员]">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b738b3d0e0a243d40111fe.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7393bd0e0a243d401121a.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b73f57d0e0a243d401134a.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7406ed0e0a243d4011368.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b740a6d0e0a243d4011371.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b741a7d0e0a243d40113a8.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7ee42d0e0a243d4013315.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7f0e5d0e0a243d40135b5.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7f632d0e0a243d4013822.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7f689d0e0a243d4013836.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7fc05d0e0a243d40139f4.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b7fd5ed0e0a243d4013a36.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b80040d0e0a243d4013abe.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b80d68d0e0a243d4013e65.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67b80f4cd0e0a243d4013f19.png">
<meta property="article:published_time" content="2025-02-20T13:43:34.000Z">
<meta property="article:modified_time" content="2025-02-21T05:30:38.865Z">
<meta property="article:author" content="Judith Hopps">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.imgdb.cn/item/67b738b3d0e0a243d40111fe.png">

<link rel="canonical" href="https://judith-hopps.github.io/2025/02/20/C-5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++_5 | Nick Wilde</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Nick Wilde</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">This is called outwit, sweetheart.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://judith-hopps.github.io/2025/02/20/C-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Judith Hopps">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nick Wilde">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++_5
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-20 21:43:34" itemprop="dateCreated datePublished" datetime="2025-02-20T21:43:34+08:00">2025-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-21 13:30:38" itemprop="dateModified" datetime="2025-02-21T13:30:38+08:00">2025-02-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Chapter5-数据的共享与保护"><a href="#Chapter5-数据的共享与保护" class="headerlink" title="Chapter5 数据的共享与保护"></a>Chapter5 数据的共享与保护</h1><p>函数间的数据共享</p>
<p>不同位置定义的变量和对象，其作用域，可见性，生存期都不同</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>作用域是一个标识符在程序正文中有效的区域</strong></p>
<h3 id="作用域分类"><a href="#作用域分类" class="headerlink" title="作用域分类"></a>作用域分类</h3><h4 id="函数原型作用域"><a href="#函数原型作用域" class="headerlink" title="函数原型作用域"></a>函数原型作用域</h4><ul>
<li><p>编译器在检查函数原型的时候，只看参数表中参数的类型，并不看参数名</p>
</li>
<li><p>在函数调用的时候，才会给形参分配空间。在声明函数原型的时候，这些形参并不对应到任何存储空间，其只是个符号</p>
</li>
</ul>
<img title="" src="https://pic1.imgdb.cn/item/67b738b3d0e0a243d40111fe.png" alt="" data-align="left" width="377">

<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><img title="" src="https://pic1.imgdb.cn/item/67b7393bd0e0a243d401121a.png" alt="" width="376" data-align="left">

<h4 id="类作用域-类成员"><a href="#类作用域-类成员" class="headerlink" title="类作用域[类成员]"></a>类作用域[类成员]</h4><ul>
<li><p><strong>其范围包括类体和非内联成员函数的函数体</strong></p>
<ul>
<li><p><strong><u>非内联成员函数的函数原型<code>void get(int x);</code>是在类体class..{public:…}里面声明的</u></strong></p>
</li>
<li><p><strong><u>而函数体的实现是在类外的。在类外实现的函数体，依然具有类作用域。比如，在类外实现函数体时，需要在前面添上类名限定符<code>clock::</code>，即<code>void clock::set(int x)&#123;...&#125;</code>,限定其为类作用域</u></strong></p>
</li>
</ul>
</li>
<li></li>
<li><p><strong>如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）</strong></p>
</li>
</ul>
<h4 id="命名空间作用域"><a href="#命名空间作用域" class="headerlink" title="命名空间作用域"></a>命名空间作用域</h4><ul>
<li><p>命名空间可以解决类名，函数名等的命名冲突</p>
</li>
<li><p>类名空间的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名</span><br><span class="line">&#123;</span><br><span class="line">    各种声明(函数声明、类声明、...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SomeNs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用类名：SomeNs::SomeClass obj1;</p>
</li>
<li><p>using语句有两种形式：</p>
<ul>
<li><p>using 命名空间名::标识符名; [这个就是仅免去其中<u>标识符名</u>的命名空间名]</p>
</li>
<li><p>using namespace 命名空间名;[&lt;-将C++标准库里面用的命名空间名字放在这里]</p>
</li>
<li><p>using namespace std;[这就将标准库里的所有标识符全都免去了命名空间名，直接可以访问，即打开了命名空间。这里是全面打开可能会导致重名的问题]</p>
</li>
</ul>
</li>
<li><p>特殊的空间名</p>
<ul>
<li><p>全局命名空间：默认的命名空间</p>
</li>
<li><p>匿名命名空间：对每个源文件时唯一的</p>
</li>
</ul>
</li>
</ul>
<h4 id="限定作用域的枚举类型"><a href="#限定作用域的枚举类型" class="headerlink" title="限定作用域的枚举类型"></a>限定作用域的枚举类型</h4><img title="" src="https://pic1.imgdb.cn/item/67b73f57d0e0a243d401134a.png" alt="" width="399" data-align="left">

<hr>
<p>如果遇到嵌套的作用域，内存与外层又出现了重名的情况，那么内层的变量就会屏蔽外层的变量。就有可能在这个作用域范围内，但是其作用域不可用的情况，所以提出了——</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><img title="" src="https://pic1.imgdb.cn/item/67b7406ed0e0a243d4011368.png" alt="" width="460" data-align="left">

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://pic1.imgdb.cn/item/67b740a6d0e0a243d4011371.png"></p>
<p>调试</p>
<p><img src="https://pic1.imgdb.cn/item/67b741a7d0e0a243d40113a8.png"></p>
<hr>
<p>有时候变量离开其作用域暂时是不可用的，但是其并没有消亡，回到其作用域时，其又是可用的。比如，从主函数中调用子函数时，当进入到子函数中以后，那么主函数的变量在子函数中都是不可用的，但是其还活着，还在其生存期内。等结束了子函数，退回到主函数中以后，主函数中定义的以前的变量都可以用。</p>
<p><strong>即使在子函数中也可以定义一个跟主函数程序运行期间一样的静态变量，让其离开作用域之后，其依然活着，其生存期是长的。下次回到子函数中还能看到其遗留的值</strong>。有点像是回一趟家，把书留在家里了，在家的时候把书折了一页。等下一次回家的时候，书的那一页还是被折着——</p>
<h2 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h2><h3 id="对象myclock的生存期"><a href="#对象myclock的生存期" class="headerlink" title="对象myclock的生存期"></a>对象myclock的生存期</h3><p>对象从产生到结束的这段时间就是它的生存期。在对象生存期内，对象将保持它的值，直到被更新为止。</p>
<h3 id="静态生存期"><a href="#静态生存期" class="headerlink" title="**静态生存期"></a>**静态生存期</h3><ul>
<li><p><strong>这种生存期与程序的生存期相同</strong></p>
</li>
<li><p><strong>文件作用域中声明的对象具有这种生存期</strong></p>
</li>
<li><p><strong><u>*在函数内部声明静态生存期对象，要冠以关键字static</u></strong>[这个就像是，手动留下了一个灯，你走的时候是把灯打开了，下次来的时候灯还是开着的]</p>
</li>
<li><p><strong>仅静态变量<code>ststic int a;</code>没有赋值时，默认赋值为0</strong></p>
</li>
</ul>
<h3 id="动态生存期-比如函数void-sum-声明处与int-a-0"><a href="#动态生存期-比如函数void-sum-声明处与int-a-0" class="headerlink" title="**动态生存期[比如函数void sum()声明处与int a&#x3D;0]"></a>**动态生存期[比如函数void sum()声明处与int a&#x3D;0]</h3><ul>
<li><p>块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯成为局部生存期对象）。</p>
</li>
<li><p><strong>开始于程序执行到声明点<code>void sum(int a,int b)</code>时，结束于该标识符的作用域结束处</strong></p>
</li>
<li><p>[比如在第五章前函数中的那些变量都是属于动态生存期]</p>
</li>
</ul>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;  <span class="comment">//i为全局变量，具有静态生存期</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">other</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="comment">//a,b为静态局部变量，具有全局寿命，局部可见&#123;这里的a,b,c与主函数中的a,b,c没有任何关系&#125;</span></span><br><span class="line">    <span class="comment">//只第一次进入函数时被初始化</span></span><br><span class="line">    <span class="type">int</span> c=<span class="number">10</span>;  <span class="comment">//c为局部变量，具有动态生存期</span></span><br><span class="line">               <span class="comment">//每次进入函数时都初始化</span></span><br><span class="line">    a+=<span class="number">2</span>;</span><br><span class="line">    i+=<span class="number">32</span>;</span><br><span class="line">    c+=<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---OTHER---\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; i: &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; c: &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    b=a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;  <span class="comment">//静态局部变量，有全局寿命，局部可见。</span></span><br><span class="line">    <span class="type">int</span> b=<span class="number">-10</span>;  <span class="comment">//b,c为局部变量，具有动态生存期</span></span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---MAIN---\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; i: &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; c: &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    i+=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">other</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;---MAIN-puls---\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; i: &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; b: &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; c: &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">other</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MAIN:       i=1,          a=0,       b=-10,    c=0;</span></span><br><span class="line"><span class="comment">//OTHER:      i=1+10+32=43, a=2+2=4,   b=0,      c=15;</span></span><br><span class="line"><span class="comment">//MAIN-puls:  i=43,         a=0,       b=-10,    c=0;</span></span><br><span class="line"><span class="comment">//OTHER-puls: i=1+42+32=74, a=4+2=6,   b=4,    c=15;</span></span><br></pre></td></tr></table></figure>

<p>值得一提：</p>
<p><code>void other() &#123;  static int a=2;  static int b;  //a,b为静态局部变量，具有全局寿命，局部可见&#123;这里的a,b,c与主函数中的a,b,c没有任何关系&#125; //且这里的初始化a=2,b=0只在第一次创建这个变量的时候有用，后面只和上一次离开的时候遗留下的值有关系</code></p>
<p>慎用：如果与以前调用过多少次，曾经被调用该有关那么就可以使用。如果需要累积记下来时就可以试试。一般尽量少用</p>
<hr>
<h2 id="对象间的共享"><a href="#对象间的共享" class="headerlink" title="对象间的共享"></a>对象间的共享</h2><ul>
<li><p>同类对象<strong>数据共享</strong>：<strong>静态数据成员</strong></p>
</li>
<li><p>同类对象<strong>功能共享</strong>：<strong>静态函数成员</strong></p>
</li>
<li><p><strong>类与外部数据共享</strong>：<strong>友元</strong>[给其他类一个函数，用于访问本类的私有成员，相当于一个授权。类似于给朋友自己家的钥匙，用于其来自己家里拿他需要的东西]</p>
</li>
</ul>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><ul>
<li><p><strong>用关键字static声明</strong></p>
</li>
<li><p><strong>为该类的所有对象共享</strong>，静态数据成员具有静态生存期[这种生存期与程序的生存期相同]</p>
</li>
<li><p><strong>一般在类外初始化，用(::)来指明所属的类</strong></p>
</li>
<li><p>c++11支持<strong>静态常量(const或constexpr修饰)类内初始化</strong>，此时<strong>类外</strong>仍可定义该静态成员，但<strong>不可再次初始化操作</strong></p>
</li>
</ul>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="** 例题"></a>**<mark> <strong>例题</mark></strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> y=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y) <span class="comment">//构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在构造函数中对count增值</span></span><br><span class="line">        <span class="comment">//对所有对象共同维护同一个cout</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制构造函数：因为这里不仅仅是简单的赋值，还要count++所以自定义复制构造函数</span></span><br><span class="line">    <span class="built_in">point</span>(point &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        x=p.x;</span><br><span class="line">        y=p.y;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数：在析构函数中对count减值。点对象生存期结束时，调用析构函数完毕后，释放空间</span></span><br><span class="line">    ~<span class="built_in">point</span>() &#123;count--;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//输出静态数据成员</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;object cout=&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:   <span class="comment">//私有数据成员</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">//静态数据成员声明，用于记录点的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态数据成员定义和初始化</span></span><br><span class="line"><span class="comment">//在类外定义的时候，不能用全局变量来定义，因为其属于point这个类，所以使用类名限定</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> point::count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">point <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;  <span class="comment">//定义对象a，其构造函数会使count增1</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;point A:&quot;</span>&lt;&lt;a.<span class="built_in">getX</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;a.<span class="built_in">getY</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//访问私有成员x,y</span></span><br><span class="line">    a.<span class="built_in">showCout</span>();  <span class="comment">////访问私有成员count，输出对象个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">point <span class="title">b</span><span class="params">(a)</span></span>;    <span class="comment">//定义对象b，其构造函数会使count增1</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;point B:&quot;</span>&lt;&lt;b.<span class="built_in">getX</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b.<span class="built_in">getY</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    b.<span class="built_in">showCout</span>();   <span class="comment">//输出对象个数（用点b来输出）</span></span><br><span class="line">    a.<span class="built_in">showCout</span>();   <span class="comment">//输出对象个数（用点a来输出）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>上面的代码中缺点在于，如果一个点都没有的时候，想问问有几个点[count值为多少]却无法问。因为这里能访问count的唯一办法是访问showcount，但是showcount只能通过调用对象才能使用。</p>
<p>也就是说，我<strong>们需要在一个对象都没有建立的情况下，还要能够访问静态数据成员count</strong>，所以引入了——</p>
<h3 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h3><ul>
<li><p><strong><u>类外代码可以使用类名和作用域操作符来调用静态成员函数。</u></strong></p>
<p>明白是某个类的功能，而不是每个静态对象的功能</p>
</li>
<li><p><strong>静态成员函数</strong>主要<strong>用于处理</strong>该类的<strong>静态数据成员</strong>，可以直接调用静态成员函数。</p>
</li>
<li><p>如果访问<strong>非静态成员</strong>，要<strong>通过对象来访问</strong></p>
</li>
</ul>
<h4 id="例题-3"><a href="#例题-3" class="headerlink" title="**例题"></a><strong><mark>**例题</mark></strong></h4><p>要构造point的概览</p>
<img title="" src="https://pic1.imgdb.cn/item/67b7ee42d0e0a243d4013315.png" alt="" data-align="left" width="307">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> y=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y) </span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">point</span>(point &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        x=p.x;</span><br><span class="line">        y=p.y;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">point</span>() &#123;count--;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出静态数据成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">showCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//与之前不同的是void showCount-&gt;static void showCount添加了static</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;object cout=&quot;</span>&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:   </span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> point::count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point::<span class="built_in">showCount</span>();   <span class="comment">//使用类名来调用对象个数：在一个对象都没有的时候也可以调用showcount了</span></span><br><span class="line">    <span class="function">point <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;  </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;point A:&quot;</span>&lt;&lt;a.<span class="built_in">getX</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;a.<span class="built_in">getY</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">    a.<span class="built_in">showCount</span>();  <span class="comment">////通过存在的对象名也可以调用对象个数函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">point <span class="title">b</span><span class="params">(a)</span></span>;    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;point B:&quot;</span>&lt;&lt;b.<span class="built_in">getX</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b.<span class="built_in">getY</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    b.<span class="built_in">showCount</span>();   </span><br><span class="line">    a.<span class="built_in">showCount</span>();   </span><br><span class="line">    point::<span class="built_in">showCount</span>();     <span class="comment">//使用类名来调用对象个数：在一个对象都没有的时候也可以调用showcount了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.<strong>静态函数[static void showCount()]中是没有this指针的。</strong></p>
<p><strong>因为静态函数属于整个类，不属于任何一个对象，所以没有隐含的this</strong></p>
<p>this只能用于非静态成员函数内部的</p>
<p>如下图</p>
<img title="" src="https://pic1.imgdb.cn/item/67b7f0e5d0e0a243d40135b5.png" alt="" data-align="left" width="502">

<p>2.<strong>非静态函数[int getX()]中有this指针。</strong></p>
<p>在执行主函数中<code>cout&lt;&lt;&quot;point A:&quot;&lt;&lt;a.getX()&lt;&lt;&quot;,&quot;&lt;&lt;a.getY()&lt;&lt;&quot; &quot;;</code>该条命令前，查询得此时a的地址  **&amp;a为(point <em>) 0x61fe08</em>*</p>
<p>下一步进入到<code>a.getX()</code>函数中时，可以发现，此时watches中<strong>this指针也为 0x61fe08</strong>。</p>
<p>运行到<code>return x</code>可知其return的其实是this-&gt;x，即this指针所指向的x。</p>
<p>可以知道<strong>每次调用非静态函数getX()时，都是通过对象名去调用</strong></p>
<h2 id="友元-单向授权"><a href="#友元-单向授权" class="headerlink" title="友元[单向授权]"></a>友元[单向授权]</h2><img title="" src="https://pic1.imgdb.cn/item/67b7f632d0e0a243d4013822.png" alt="" width="525" data-align="left">

<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><img title="" src="https://pic1.imgdb.cn/item/67b7f689d0e0a243d4013836.png" alt="" width="515" data-align="left">

<h4 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;  <span class="comment">//point类声明</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//外部接口</span></span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">int</span> y=<span class="number">0</span>):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="comment">//友元函数声明。</span></span><br><span class="line">    <span class="comment">//其位置不固定，public,private都可以，他只是找个位置声明一下</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">float</span> <span class="title">dist</span><span class="params">(point &amp;a,point &amp;b)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//友元函数</span></span><br><span class="line"><span class="comment">//(point&amp; a,point&amp; b)表示a是p1的别名,b是p2的别名。</span></span><br><span class="line"><span class="comment">//这就意味着二者是双向的关系，a改变了，p1也会跟着改变。有点危险</span></span><br><span class="line"><span class="comment">//所以要求变为了1.要传引用2.能够把私有成员的访问开放给dist函数3.还不希望在函数中破坏主函数的实参p1,p2——共享数据的保护。使用常引用作为实参</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">dist</span><span class="params">(point&amp; a,point&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> x=a.x-b.x;</span><br><span class="line">    <span class="type">double</span> y=a.y-b.y;</span><br><span class="line">    <span class="comment">//这里转为float类型是因为sqrt的返回类型是double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">sqrt</span>(x*x+y*y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">point <span class="title">p1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>,<span class="title">p2</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the distance is:&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dist</span>(p1,p2)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ul>
<li><p>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员</p>
</li>
<li><p>声明语法：将友元类名在另一个类中使用friend修饰说明</p>
</li>
</ul>
<h4 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h4><img title="" src="https://pic1.imgdb.cn/item/67b7fc05d0e0a243d40139f4.png" alt="" width="538" data-align="left">

<p>B：类的组装，部件组合</p>
<p>B得到A的部件装上，但是A这个生产厂不给授权打开A的封装调整内部参数。</p>
<p>所以friend class B;就是用于此，将A的内部参数拿来用；</p>
<p><strong>写friend的那个是给授权，不是要权</strong></p>
<p>B的所有成员函数，都成为A的友元函数，就可以访问A中的私有成员了</p>
<h4 id="类的友元关系是单向的"><a href="#类的友元关系是单向的" class="headerlink" title="**类的友元关系是单向的"></a>**<strong>类的友元关系是单向的</strong></h4><img title="" src="https://pic1.imgdb.cn/item/67b7fd5ed0e0a243d4013a36.png" alt="" width="518">

<hr>
<p><strong>对于既需要共享，又需要防止改变的数据应该声明为常类型（用const进行修饰）</strong></p>
<p><strong>对于不改变对象状态的成员函数应该声明为常函数</strong></p>
<h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><h3 id="常类型-基本语法"><a href="#常类型-基本语法" class="headerlink" title="** 常类型[基本语法]"></a>**<mark> <strong>常类型[基本语法]</mark></strong></h3><ul>
<li><p><strong>常对象：</strong></p>
<p>必须进行初始化，不能被更新。</p>
<p>const 类名 对象名  [在class A之外<code>A const a(3,4);</code></p>
</li>
<li><p><strong>常成员</strong></p>
<p>用const进行修<strong>饰的类成员</strong>：常数据成员和常函数成员。</p>
</li>
<li><p><strong>常引用</strong></p>
<p>被引用的对象不能被更新。</p>
<p>比如<code>float dist(point&amp; a,point&amp; b)</code>这里为了不修改到主函数的p1引入</p>
<p>const 类型说明符 &amp;引用名</p>
</li>
<li><p><strong>常数组</strong></p>
<p>类型说明符 const 数组名[大小]….</p>
</li>
<li><p><strong>常指针</strong></p>
<p>指向常量的指针[第六章]</p>
</li>
</ul>
<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><img title="" src="https://pic1.imgdb.cn/item/67b80040d0e0a243d4013abe.png" alt="" width="342" data-align="left">

<p>1.赋值2.set值3.move…</p>
<hr>
<p><strong>一个常对象无法调用一个普通的函数，所以引入了常成员函数</strong></p>
<h4 id="常成员"><a href="#常成员" class="headerlink" title="常成员"></a>常成员</h4><h5 id="函数成员可以定义为常成员"><a href="#函数成员可以定义为常成员" class="headerlink" title="函数成员可以定义为常成员"></a>函数成员可以定义为常成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">R</span>(<span class="type">int</span> r1,<span class="type">int</span> r2):<span class="built_in">r1</span>(r1),<span class="built_in">r2</span>(r2) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> r1,r2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;r1&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个const对象是不能用一个普通函数来操作的 所以需要另起一个相同的函数末尾给上承诺声明const</span></span><br><span class="line"><span class="comment">//这个声明的意思是，我是绝对不会改变对象状态的</span></span><br><span class="line"><span class="comment">//有了这个声明，编译器在执行时，会特别注意这个对象的状态有没有被改变。没有变，OL，变了。报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;r1&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">print</span>(); <span class="comment">//调用void print()</span></span><br><span class="line">    <span class="function"><span class="type">const</span> R <span class="title">b</span><span class="params">(<span class="number">20</span>,<span class="number">52</span>)</span></span>;   <span class="comment">//常对象</span></span><br><span class="line">    b.<span class="built_in">print</span>();  <span class="comment">//调用void print() const</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.<code>void R::print() const</code>与<code>void R::print()</code>一定需要两个版本吗？</p>
<p><u>根据需要，如果这两个函数体内部是一模一样的，可以只留下<code>void R::print() const</code>这个，既可以让非常对象进行调用这个函数，也可以便于声明常对象也能用。</u></p>
<p>因为对于不带const承诺的<code>void R::print()</code>，常对象无法使用</p>
<hr>
<h5 id="数据成员定义为常成员"><a href="#数据成员定义为常成员" class="headerlink" title="数据成员定义为常成员"></a>数据成员定义为常成员</h5><p>例题：</p>
<p><strong>静态常数据成员：</strong></p>
<ul>
<li><p><strong>static表示为该类的所有对象共享</strong></p>
</li>
<li><p><strong>const表示这个b数据是一直不变不能改动的</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i);  <span class="comment">//自定义类的构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;  <span class="comment">//类的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;  <span class="comment">//账号数字不能变的，余额是可以变的</span></span><br><span class="line">    <span class="comment">//静态常数据成员，例如pi，为整个类对象共享，但值不能变</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> b; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>A::A(int i):a(i)&#123;&#125;</code></p>
<p>在之前的学习中，a在初始化列表中进行初始化即<code>A::A(int i):a(i)</code>，也可以放在{}进行初始化即<code>A::A(int i)&#123;a=i;&#125;</code>。</p>
<p>但是在这里，由于a被<code>const int a;</code>成为常数据成员了，无法赋值改变状态，所以第二种放在大括号中的初始化就会报错了，只能使用第一种</p>
<p><strong>常成员，在任何地方都不能在其上面运行赋值表达式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> A::b=<span class="number">10</span>; <span class="comment">//关于b的类外初始化。A::b用于表示b限定在A这个大类中</span></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> i):<span class="built_in">a</span>(i)&#123;&#125;  <span class="comment">//关于类A的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;b&lt;&lt;endl; <span class="comment">//若是在这里改变了a的值比如a=8;会直接报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>主函数</p>
<p>建立对象a和b，并以100和0作为初值，分别调用构造函数，</p>
<p>通过构造函数的初始化列表给对象的常数据成员初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">100</span>)</span>,<span class="title">a2</span><span class="params">(<span class="number">0</span>)</span>：</span></span><br><span class="line"><span class="function">    a1.<span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    a<span class="number">2.</span><span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>大部分的时候，<strong>传对象的引用</strong><code>(point&amp; a)</code>[一般传引用不传值]过去并不需要双向传递，不需要把a的状态进行改变，<strong>不需要破坏实参</strong>，所以提出了——</p>
<h3 id="常引用-前面提及的float-dist-point-a-问题"><a href="#常引用-前面提及的float-dist-point-a-问题" class="headerlink" title="常引用[前面提及的float dist(point&amp; a)问题]"></a>常引用[前面提及的float dist(point&amp; a)问题]</h3><img title="" src="https://pic1.imgdb.cn/item/67b80d68d0e0a243d4013e65.png" alt="" width="429" data-align="left">

<p>所以友元函数中，为保单向传递：</p>
<p>1.把class中的友元声明<code>friend float dist(point &amp;p1,point &amp;p2);</code></p>
<p>改为了<code>friend float dist(const point &amp;p1,const point &amp;p2);</code></p>
<p>2.把类外定义的友元定义函数初始化部分<code>float dist(point &amp;p1,point &amp;p2)&#123;&#125;</code></p>
<p>改为了<code>float dist(const point &amp;p1,const point &amp;p2)&#123;&#125;</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img title="" src="https://pic1.imgdb.cn/item/67b80f4cd0e0a243d4013f19.png" alt="" width="464" data-align="left">

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/19/C-4/" rel="prev" title="C++_4">
      <i class="fa fa-chevron-left"></i> C++_4
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/21/c-6/" rel="next" title="c-6">
      c-6 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter5-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.</span> <span class="nav-text">Chapter5 数据的共享与保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.1.</span> <span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">作用域分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">函数原型作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">局部作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F-%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">类作用域[类成员]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">命名空间作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%90%E5%AE%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">限定作用域的枚举类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">1.3.</span> <span class="nav-text">生存期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1myclock%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">对象myclock的生存期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">**静态生存期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%94%9F%E5%AD%98%E6%9C%9F-%E6%AF%94%E5%A6%82%E5%87%BD%E6%95%B0void-sum-%E5%A3%B0%E6%98%8E%E5%A4%84%E4%B8%8Eint-a-0"><span class="nav-number">1.3.3.</span> <span class="nav-text">**动态生存期[比如函数void sum()声明处与int a&#x3D;0]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="nav-number">1.3.4.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="nav-number">1.4.</span> <span class="nav-text">对象间的共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-number">1.4.1.</span> <span class="nav-text">静态数据成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">** 例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="nav-number">1.4.2.</span> <span class="nav-text">静态函数成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">**例题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83-%E5%8D%95%E5%90%91%E6%8E%88%E6%9D%83"><span class="nav-number">1.5.</span> <span class="nav-text">友元[单向授权]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.1.</span> <span class="nav-text">友元函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-number">1.5.2.</span> <span class="nav-text">友元类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">例题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB%E6%98%AF%E5%8D%95%E5%90%91%E7%9A%84"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">**类的友元关系是单向的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="nav-number">1.6.</span> <span class="nav-text">共享数据的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.6.1.</span> <span class="nav-text">** 常类型[基本语法]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">常对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%88%90%E5%91%98"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">常成员</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%B8%B8%E6%88%90%E5%91%98"><span class="nav-number">1.6.1.2.1.</span> <span class="nav-text">函数成员可以定义为常成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%B8%B8%E6%88%90%E5%91%98"><span class="nav-number">1.6.1.2.2.</span> <span class="nav-text">数据成员定义为常成员</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8-%E5%89%8D%E9%9D%A2%E6%8F%90%E5%8F%8A%E7%9A%84float-dist-point-a-%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.2.</span> <span class="nav-text">常引用[前面提及的float dist(point&amp; a)问题]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Judith Hopps</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Judith Hopps</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
